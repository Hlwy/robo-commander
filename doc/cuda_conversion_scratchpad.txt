int Vboats::process(const cv::Mat& depth, cv::Mat* filtered_input,
     std::vector<Obstacle>* found_obstacles, std::vector<float>* line_coefficients,
     cv::Mat* disparity_output, cv::Mat* umap_output, cv::Mat* vmap_output,
     cv::Mat* umap_input, cv::Mat* vmap_input,
     bool verbose_obstacles, bool debug
){
     if(depth.empty()){
          printf("[WARNING] %s::process() --- Depth input is empty.\r\n", this->classLbl.c_str());
          return -1;
     }
     if(!this->_have_cam_info){
          printf("[WARNING] %s::process() --- Camera Information Unknown.\r\n", this->classLbl.c_str());
          return -2;
     }

     /** DONT CUDA-FY */
     cv::Mat depthRaw = depth.clone();
     cv::Mat disparity = this->generate_disparity_from_depth(depthRaw);
     if(disparity.empty()){
          printf("[WARNING] %s::process() --- Disparity input is empty.\r\n", this->classLbl.c_str());
          return -3;
     }
     cv::Mat disparityRaw = disparity.clone();

     /** CUDA-FY */
     cv::Mat depthInput, disparityInput;
     double correctionAngle = this->get_correction_angle(true, this->_flip_correction_angle_sign);
     if(this->_do_angle_correction){
          cv::Mat warpedDepth = rotate_image(depthRaw, correctionAngle);
          cv::Mat warpeddDisparity = rotate_image(disparityRaw, correctionAngle);

          if(!warpedDepth.empty() && !warpeddDisparity.empty()){
               depthInput = warpedDepth.clone();
               disparityInput = warpeddDisparity.clone();
               this->_angle_correction_performed = true;
          } else{
               depthInput = depthRaw; disparityInput = disparityRaw;
               this->_angle_correction_performed = false;
          }
     } else{
          depthInput = depthRaw;  disparityInput = disparityRaw;
          this->_angle_correction_performed = false;
     }
     if(disparity_output) *disparity_output = disparityInput.clone();

     /** MAYBE CUDA-FY */
     cv::Mat umap, vmap;
     genUVMapThreaded(disparityInput, &umap, &vmap, 2.0);
     if(umap.empty()){
          printf("[WARNING] %s::process() --- Umap input is empty.\r\n", this->classLbl.c_str());
          return -4;
     }
     if(vmap.empty()){
          printf("[WARNING] %s::process() --- Vmap input is empty.\r\n", this->classLbl.c_str());
          return -5;
     }
     cv::Mat umapRaw = umap.clone();
     cv::Mat vmapRaw = vmap.clone();

     /** CUDA-FY */
     // Pre-process Umap
     cv::Mat uProcessed = this->remove_umap_deadzones(umapRaw);
     if(this->_umapFiltMeth == SOBELIZED_METHOD){ uProcessed = preprocess_umap_sobelized(); }
     /**  END CUDA-FY */

     /** MAYBE CUDA-FY */
     // Find contours in Umap needed later for obstacle filtering
     vector<vector<cv::Point>> filtered_contours;
     find_contours();

     /** CUDA-FY */
     // Pre-process Vmap
     cv::Mat preprocessedVmap = this->remove_vmap_deadzones(vmapRaw);
     if(this->_vmapFiltMeth == SOBELIZED_METHOD){
          preprocessedVmap = preprocess_vmap_sobelized();
     }

     // Extract ground line parameters (if ground is present)
     std::vector<float> line_params;
     bool gndPresent = find_ground_line(preprocessedVmap, &line_params,
          this->vmapParams.gnd_line_search_min_deg,
          this->vmapParams.gnd_line_search_max_deg,
          this->vmapParams.gnd_line_search_deadzone,
          this->vmapParams.gnd_line_search_hough_thresh
     );

     /** Possibly do after cuda-fied vmap processing */
     float delta_slope   = 0;
     int delta_intercept = 0;
     if(!line_params.empty()){
          // Noisy Ground Line Filtering stuff here
     }
     /** End Possibly do after cuda-fied vmap processing */

     // Finish V-map processing starting from the pre-processed vmap
     cv::Mat vProcessed = preprocessedVmap.clone();
     if(this->_vmapFiltMeth == SOBELIZED_METHOD){ vProcessed = postprocess_vmap_sobelized(); }
     /** END CUDA-FY */

     // Obstacle data extraction
     std::vector<Obstacle> obstacles_;
     if(this->_do_obstacle_data_extraction){ nObs = find_obstacles_disparity(); }

     // Filter the original depth image using all the useful data encoded within the resulting processed UV-Maps
     cv::Mat filtered_image;
     int err = filter_depth_using_object_candidate_regions();

     cv::Mat filtered_depth;
     err = filter_depth_using_ground_line();

     /** CUDA-FY */
     // Attempt to remove any noise (speckles) from the resulting filtered depth image
     cv::Mat final_depth;
     if(this->_denoise_filtered_depth){
          cv::Mat morphElement = cv::getStructuringElement(cv::MORPH_ELLIPSE,
               cv::Size(this->_filtered_depth_denoising_size, this->_filtered_depth_denoising_size)
          );
          cv::Mat morphedDepth;
          cv::morphologyEx(filtered_depth, morphedDepth, cv::MORPH_OPEN, morphElement);
          final_depth = morphedDepth.clone();
     } else final_depth = filtered_depth.clone();

     if(this->_do_angle_correction && this->_angle_correction_performed) final_depth = rotate_image(final_depth, -correctionAngle);
     /** END CUDA-FY */

     // Return Output images if requested before visualization
     return (int) obstacles_.size();
}
